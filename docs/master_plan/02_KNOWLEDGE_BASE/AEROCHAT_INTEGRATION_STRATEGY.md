# AeroChat Integration Strategy for ADK Minions

## I. Introduction

This document outlines the comprehensive strategy for integrating the advanced communication dynamics and features of the AeroChat system (prototyped in `llmchat`) into the Python Agent Development Kit (ADK) Minions. The primary goal is to imbue ADK Minions with more natural, context-aware, and emotionally resonant conversational capabilities, aligning with the "Visionary Blueprint" for "Operation Gemini Legion - Phase Zero." This strategy details the porting of mandatory AeroChat features and outlines a vision for future enhancements.

## II. Core Integration Principles

The integration of AeroChat features into ADK Minions will adhere to the following core principles:

*   **Leverage ADK Agent Lifecycle:** Utilize the existing ADK `LlmAgent` lifecycle methods, primarily `awake()` for initial persona and system prompt setup, and `think()` (which typically calls `predict()`) for processing incoming messages and generating responses.
*   **Enhanced Prompt Engineering:** Adapt and extend the prompt engineering techniques from `llmchat`, including system prompts for internal state management (diaries) and meta-prompts for guiding turn-specific tasks.
*   **Minion State Augmentation:** Minions will maintain an internal "diary" reflecting their perceived emotional state, opinions of other participants, and response dispositions. This state will be generated by the LLM and persisted.
*   **Modular Context Services:** Where ADK does not provide direct equivalents, modular services (e.g., for channel context management or dedicated diary persistence) will be proposed, aiming for compatibility and potential future integration with ADK's native services like `ArtifactService`.
*   **Iterative Development:** Mandatory features will be integrated first, establishing a foundation for more advanced AeroChat capabilities in subsequent phases.

## III. Mandatory AeroChat Feature Integration (Porting from `llmchat`)

This section details the plan for integrating essential AeroChat features into ADK Minions.

### A. Conversational Turn-Taking Logic

The ability for Minions to decide when and how to participate in a conversation dynamically is crucial. This involves direct address checks, relevance filtering, persona alignment, and probabilistic responses.

**1. Current `llmchat` Mechanism:**

*   The `llmchat` prototype uses an `EMOTIONAL_ENGINE_SYSTEM_PROMPT` (defined in [`llmchat/backend_app/llm_core/prompts.py`](../../../../llmchat/backend_app/llm_core/prompts.py:13)) to instruct the LLM on maintaining an internal analysis system (perception, opinion scores, response guidelines, diary).
*   A `generate_meta_prompt` function (in [`llmchat/backend_app/llm_core/prompts.py`](../../../../llmchat/backend_app/llm_core/prompts.py:41)) creates turn-specific instructions for the LLM, guiding it through checks for direct address, relevance, and the decision to engage.
*   The `trigger_llm_responses_stream` function in [`llmchat/backend_app/llm_core/trigger_logic.py`](../../../../llmchat/backend_app/llm_core/trigger_logic.py:29) manages which LLMs respond. If an LLM is not directly addressed but chooses to speak (based on relevance), a probabilistic silence check is applied based on its opinion score towards the sender of the last message (logic found around lines [`128-146`](../../../../llmchat/backend_app/llm_core/trigger_logic.py:128) and [`170-190`](../../../../llmchat/backend_app/llm_core/trigger_logic.py:170)).

**2. Proposed ADK Minion Integration Strategy:**

*   **System Prompt Injection:**
    *   An adapted version of the `EMOTIONAL_ENGINE_SYSTEM_PROMPT` will be integrated into each Minion. This will likely occur during the `MinionAgent.awake()` method using `self.set_instructions()`. The prompt will be tailored for ADK Minions and will include dynamic placeholders for active participants in the current communication channel.
    *   This system prompt will guide the Minion LLM to perform internal diary updates as part of every thought cycle.

*   **Meta-Prompt Adaptation for `think`/`predict`:**
    *   The logic from `llmchat`'s `generate_meta_prompt` will be adapted. This "meta-task" instruction set will be constructed within the `MinionAgent.think()` method and prepended to the actual incoming message/event data before calling `await self.predict(full_prompt)`.
    *   This adapted meta-prompt will instruct the ADK Minion's LLM to:
        1.  Execute its internal diary update procedure (as defined by the `EMOTIONAL_ENGINE_SYSTEM_PROMPT`).
        2.  Perform a **Direct Address Check**: Determine if the Minion itself (e.g., `{self.name}` or `{self.minion_id}`) was directly mentioned or addressed in the last message.
        3.  Perform a **Relevance Check**: Assess if the last message is relevant to its defined persona, current assigned tasks, or ongoing conversation threads it's actively participating in.
        4.  Make a **Decision to Engage**: Based on being directly addressed OR deeming the message relevant, and critically, considering its current internal "Response Mode" (derived from its opinion score of the sender, as per its diary), decide whether to formulate a response. A hostile or minimal response mode might lead to silence even if addressed/relevant.
        5.  **Generate Response or `[SILENT]`**: If the decision is to engage, craft a chat message. Otherwise, output only the token `[SILENT]`.

*   **Probabilistic Response Implementation:**
    *   If a Minion's LLM decides to generate a response *but* it was not directly addressed, the ADK framework (or logic within the `MinionAgent.think()` method, after the `self.predict()` call) will perform a probabilistic silence check.
    *   This check will use the Minion's newly updated opinion score for the sender (extracted from the just-generated diary). If a random roll exceeds the opinion score, the Minion's intended response will be suppressed, and it will remain silent for that turn.

*   **Mermaid Diagrams for Turn-Taking Scenarios:**

    *   **Scenario 1: Minion Directly Addressed & Responds:**
        ```mermaid
        sequenceDiagram
            participant User
            participant ChannelOrchestrator as Orchestrator
            participant MinionAgent as Minion
            participant MinionLLM as LLM
            participant DiaryDB as Diary/Context DB

            User->>Orchestrator: Sends message to Minion
            Orchestrator->>Minion: Forwards message (prompt)
            Minion->>DiaryDB: Get last diary state
            DiaryDB-->>Minion: Last diary JSON
            Minion->>Minion: Construct full prompt (System + Meta + Diary + User Msg)
            Minion->>LLM: Call predict(full_prompt)
            LLM-->>Minion: Raw response (Diary JSON + Chat Msg)
            Minion->>Minion: Parse diary & chat message
            Minion->>DiaryDB: Save updated diary
            Minion->>Orchestrator: Returns chat message
            Orchestrator->>User: Relays Minion's chat message
        end
        ```

    *   **Scenario 2: Minion Not Directly Addressed, Relevance & Opinion Score Lead to Response:**
        ```mermaid
        sequenceDiagram
            participant User
            participant ChannelOrchestrator as Orchestrator
            participant MinionAgent as Minion
            participant MinionLLM as LLM
            participant DiaryDB as Diary/Context DB
            participant ProbabilisticLogic as ADK Framework Logic

            User->>Orchestrator: Sends general channel message
            Orchestrator->>Minion: Forwards message (prompt)
            Minion->>DiaryDB: Get last diary state
            DiaryDB-->>Minion: Last diary JSON
            Minion->>Minion: Construct full prompt (System + Meta + Diary + User Msg)
            Minion->>LLM: Call predict(full_prompt)
            LLM-->>Minion: Raw response (Diary JSON + Chat Msg - LLM decides to speak based on relevance)
            Minion->>Minion: Parse diary & chat message
            Minion->>DiaryDB: Save updated diary
            Minion->>ProbabilisticLogic: Provide intended Chat Msg & Sender's Opinion Score from new diary
            ProbabilisticLogic->>ProbabilisticLogic: Perform probabilistic check (Roll <= Score)
            ProbabilisticLogic-->>Minion: Decision: Proceed with response
            Minion->>Orchestrator: Returns chat message
            Orchestrator->>User: Relays Minion's chat message
        end
        ```

    *   **Scenario 3: Minion Not Directly Addressed, Probabilistic Silence Occurs:**
        ```mermaid
        sequenceDiagram
            participant User
            participant ChannelOrchestrator as Orchestrator
            participant MinionAgent as Minion
            participant MinionLLM as LLM
            participant DiaryDB as Diary/Context DB
            participant ProbabilisticLogic as ADK Framework Logic

            User->>Orchestrator: Sends general channel message
            Orchestrator->>Minion: Forwards message (prompt)
            Minion->>DiaryDB: Get last diary state
            DiaryDB-->>Minion: Last diary JSON
            Minion->>Minion: Construct full prompt (System + Meta + Diary + User Msg)
            Minion->>LLM: Call predict(full_prompt)
            LLM-->>Minion: Raw response (Diary JSON + Chat Msg - LLM decides to speak based on relevance)
            Minion->>Minion: Parse diary & chat message
            Minion->>DiaryDB: Save updated diary
            Minion->>ProbabilisticLogic: Provide intended Chat Msg & Sender's Opinion Score from new diary
            ProbabilisticLogic->>ProbabilisticLogic: Perform probabilistic check (Roll > Score)
            ProbabilisticLogic-->>Minion: Decision: Stay Silent
            Minion->>Orchestrator: Returns [SILENT] indication (or nothing)
            Note over Orchestrator, User: No message relayed
        end
        ```
    *   **Scenario 4: LLM Itself Decides `[SILENT]` Based on Internal Hostility (System Prompt):**
        ```mermaid
        sequenceDiagram
            participant User
            participant ChannelOrchestrator as Orchestrator
            participant MinionAgent as Minion
            participant MinionLLM as LLM
            participant DiaryDB as Diary/Context DB

            User->>Orchestrator: Sends message (even if addressing Minion)
            Orchestrator->>Minion: Forwards message (prompt)
            Minion->>DiaryDB: Get last diary state
            DiaryDB-->>Minion: Last diary JSON (shows high hostility to User in opinion_scores)
            Minion->>Minion: Construct full prompt (System + Meta + Diary + User Msg)
            Minion->>LLM: Call predict(full_prompt)
            LLM-->>Minion: Raw response (Diary JSON + "[SILENT]")
            Minion->>Minion: Parse diary & SILENT response
            Minion->>DiaryDB: Save updated diary
            Minion->>Orchestrator: Returns [SILENT] indication
            Note over Orchestrator, User: No message relayed
        end
        ```

**3. Challenges & Considerations:**

*   **Prompt Complexity:** Managing the combined length and complexity of the system prompt, meta-prompt, channel history, and user message to stay within LLM context windows and ensure effective processing.
*   **ADK `predict()` Behavior:** Ensuring the ADK `LlmAgent.predict()` method correctly handles these rich prompts and that the chosen LLM (e.g., Gemini series) responds reliably to the structured instructions.
*   **Participant Synchronization:** A robust mechanism will be needed to provide Minions with an up-to-date list of active participants for their system prompts.
*   **State Management:** Efficiently retrieving and injecting the `previous_diary_state` for each Minion on each turn.

### B. Personal Diaries (Emotional Engine Memory)

Minions will maintain "Personal Diaries" to track their internal state, influencing their behavior and providing continuity.

**1. Current `llmchat` Mechanism:**

*   The LLM generates a diary JSON object (containing perception, opinion scores, response mode, personal notes) within defined delimiters, guided by the `EMOTIONAL_ENGINE_SYSTEM_PROMPT`.
*   [`llmchat/backend_app/llm_core/diary_utils.py`](../../../../llmchat/backend_app/llm_core/diary_utils.py:0) provides `extract_and_clean_diary` to parse this JSON from the LLM's raw output and `format_diary_for_injection` to prepare a past diary for the next prompt.
*   [`llmchat/backend_app/database.py`](../../../../llmchat/backend_app/database.py:0) stores these diary JSON objects as strings in an `internal_diary` TEXT column in an SQLite database (see `upsert_message_in_db`). It also provides `get_last_diary_for_llm` to retrieve the most recent diary for a given LLM.

**2. Proposed ADK Minion Integration Strategy:**

*   **Diary Generation:** ADK Minions, guided by their version of the `EMOTIONAL_ENGINE_SYSTEM_PROMPT`, will generate their diary as a JSON object embedded within their raw LLM response (prior to any `[SILENT]` token).
*   **Diary Parsing:** After the `await self.predict()` call in `MinionAgent.think()`, logic equivalent to `extract_and_clean_diary` will be used to separate the diary JSON from the Minion's intended chat message or action.
*   **Diary Storage:**
    *   **Option 1: Dedicated SQLite Database (Preferred for Decoupling/Similarity):**
        *   A SQLite database (potentially shared or one per Legion/service group) will store diary entries.
        *   A table schema like `(minion_id TEXT, timestamp TEXT, diary_content TEXT, PRIMARY KEY (minion_id, timestamp))` would allow efficient retrieval of the latest diary for each Minion.
        *   Helper functions within ADK, accessible to Minions or a Minion service layer, would manage `save_diary(minion_id, diary_obj)` and `get_last_diary(minion_id)`.
    *   **Option 2: ADK `ArtifactService` Investigation:**
        *   ADK's `ArtifactService` will be evaluated for its suitability. Key questions include:
            *   Can it efficiently store and retrieve relatively small, structured JSON objects per Minion, per turn?
            *   Does it support versioning or a straightforward way to get the "latest" diary entry for a Minion?
            *   What are the performance implications for frequent read/write operations?
        *   If viable, Minions would use `ArtifactService` to save their diary JSON (e.g., `artifact_name = f"diary/{self.minion_id}/latest"`) and retrieve it.
*   **Diary Retrieval & Re-injection:**
    *   Before each call to `self.predict()`, the `MinionAgent.think()` method will fetch the Minion's most recent diary state from the chosen storage mechanism.
    *   This diary object will be formatted into a JSON string (using logic like `format_diary_for_injection`) and injected into the `previous_diary_state` field of the `EMOTIONAL_ENGINE_SYSTEM_PROMPT` for the current LLM call. If no previous diary exists (e.g., first turn), "null" will be injected.
*   **Debugging and Consistency Plan:**
    *   Implement comprehensive logging around the diary generation, parsing, storage, and retrieval processes.
    *   Define a Pydantic model for the diary structure to validate parsed diary objects.
    *   Conduct iterative testing and prompt refinement to ensure Minions consistently produce well-formed diaries.

*   **Mermaid Diagram: Diary Update and Retrieval Flow (Conceptual):**
    ```mermaid
    sequenceDiagram
        participant MinionAgent as Minion
        participant MinionLLM as LLM
        participant DiaryStorage as Diary Storage (SQLite/ArtifactService)

        Minion->>DiaryStorage: Request last diary (minion_id)
        DiaryStorage-->>Minion: Previous Diary JSON / null
        Minion->>MinionLLM: predict(prompt_including_previous_diary)
        MinionLLM-->>Minion: LLM Output (New Diary JSON + Response)
        Minion->>Minion: Extract New Diary JSON
        Minion->>DiaryStorage: Save New Diary (minion_id, new_diary_json)
        DiaryStorage-->>Minion: Confirmation
    end
    ```

*   **Mermaid Diagram: Diary Storage Options (Conceptual Components):**
    ```mermaid
    graph TD
        subgraph Minion Agent
            direction LR
            A[Minion Logic e.g., think()]
        end

        subgraph Storage Option 1: Dedicated SQLite
            B[SQLite DB]
            C[DiaryTable schema: minion_id TEXT, timestamp TEXT, diary_json_string TEXT]
            D[DB Access Helper/Service]
            B --- C
        end
        A -.-> D
        D <--> B

        subgraph Storage Option 2: ADK ArtifactService
            E[ADK ArtifactService]
            F[Artifact Naming: diaries/{minion_id}/latest.json OR diaries/{minion_id}/{timestamp}.json]
        end
        A -.-> E

        MinionAgent --> |Option 1| DedicatedSQLite
        MinionAgent --> |Option 2| ADKArtifactService
    end
    ```

**3. Challenges & Considerations:**

*   **Storage Scalability:** The chosen diary storage solution must efficiently handle a potentially large number of Minions generating entries frequently.
*   **Data Integrity:** Robust error handling for JSON parsing and database operations is essential.
*   **Performance:** Diary retrieval and saving should be fast to avoid adding significant latency to Minion response times.
*   **Concurrency:** If a shared SQLite database is used, appropriate locking or connection management will be needed for concurrent access.

### C. Channel Memory & Slack-like Channels

Minions need access to the context of the communication channel they are participating in, including recent messages, participant lists, and channel purpose.

**1. Current `llmchat` Mechanism:**

*   `llmchat` retrieves recent history from the database (`get_recent_history_from_db`) which implicitly serves as channel memory for the LLMs.
*   The concept of a `ChatCoordinatorAgent` is mentioned, suggesting a central point for managing chat contexts and participants.
*   The API contract ([`../01_API_CONTRACT_V1.md`](../../../../docs/master_plan/01_API_CONTRACT_V1.md:0)) defines endpoints for channel management, which implies channels have defined participants and history.
*   Channel types (User+Minions, User+OneMinion, Minion+Minion) are handled by controlling which LLMs are active or triggered for a given message.

**2. Proposed ADK Minion Integration Strategy:**

*   **Channel Context Service:**
    *   A dedicated "Channel Context Service" (or an agent with this role, e.g., an enhanced `ChatCoordinatorAgent` for ADK) will be developed.
    *   Responsibilities:
        *   Managing channel metadata (ID, topic/purpose, creation timestamp).
        *   Tracking current participants (users and Minions) for each channel.
        *   Storing and providing access to recent message history specific to each channel. This might leverage the same database used for diaries but with queries partitioned by `channel_id`.
*   **Contextual Information for Minions:**
    *   When a Minion is invoked to process a message in a specific channel, its `think()` method (or the orchestrator calling it) will first query the Channel Context Service.
    *   The Minion will receive:
        *   An up-to-date list of **active participants** in that channel. This list is crucial for the `EMOTIONAL_ENGINE_SYSTEM_PROMPT` to correctly scope opinion scores.
        *   A segment of **recent message history** from that channel. This history will be part of the input to the Minion's LLM, included in the adapted meta-prompt.
        *   The **channel's topic or purpose**, if defined, to further ground the Minion's responses.
*   **Interfacing with API Contract:**
    *   The channel management endpoints defined in the API contract ([`../01_API_CONTRACT_V1.md`](../../../../docs/master_plan/01_API_CONTRACT_V1.md:0)) (e.g., create channel, add/remove participant) will interact with this Channel Context Service to update channel states.
*   **Handling Different Channel Types:**
    *   **User + Minions (Group Chat):** All Minions in the channel receive the message notification. Each Minion individually runs its turn-taking logic (including probabilistic silence) based on the shared channel context.
    *   **User + One Minion (Direct Message/Task):** Similar to group chat, but the participant list is limited, simplifying context for the Minion.
    *   **Minion + Minion:** For inter-Minion communication, a dedicated channel context can be established. One Minion "sends" a message (which might be an internal event or a structured data packet), and the recipient Minion(s) process it using the same AeroChat logic, including diary updates based on their "opinions" of the sending Minion.

*   **Mermaid Diagram: Channel Context Flow for Minion Response:**
    ```mermaid
    sequenceDiagram
        participant User
        participant ChannelOrchestrator as Orchestrator
        participant MinionAgent
        participant ChannelContextService as CCS
        participant MinionLLM
        participant DiaryStorage

        User->>Orchestrator: Sends message to Channel X
        Orchestrator->>MinionAgent: Notify: New message in Channel X (content, sender, channel_id)
        MinionAgent->>CCS: Get context for Channel X (participants, recent_history, topic)
        CCS-->>MinionAgent: Channel Context Data
        MinionAgent->>DiaryStorage: Get self.last_diary_state
        DiaryStorage-->>MinionAgent: Last Diary JSON
        MinionAgent->>MinionAgent: Construct full_prompt (SystemPrompt_with_ChannelParticipants + MetaPrompt_with_ChannelHistory + LastDiary + Message)
        MinionAgent->>MinionLLM: predict(full_prompt)
        MinionLLM-->>MinionAgent: LLM Output (New Diary + Chat Response / SILENT)
        MinionAgent->>DiaryStorage: Save New Diary
        MinionAgent->>Orchestrator: Send Chat Response / SILENT for Channel X
        Orchestrator-->>User: Relay Minion's response (if not SILENT)
    end
    ```

**3. Challenges & Considerations:**

*   **Scalability of Channel Context Service:** The service must efficiently manage context for numerous concurrent channels and Minions.
*   **Real-time Updates:** Ensuring participant lists and recent history are provided to Minions in a timely manner.
*   **Context Granularity:** Determining the optimal amount of history and context to provide to Minions without overwhelming the LLM or exceeding token limits.
*   **Minion Discovery in Channels:** Defining how Minions become aware of and "join" relevant channels.

## IV. Secondary AeroChat Features (Future Vision)

Once the mandatory features are robustly implemented, the following advanced AeroChat capabilities can be layered in, leveraging the foundational `llmchat` concepts:

*   **Fully Dynamic Personalities:**
    *   The current `personality_traits_str` provides a baseline. Future enhancements could allow Minions to evolve these core traits over longer periods.
    *   This might involve a mechanism where the Minion's LLM, based on extensive interaction patterns recorded in its diary history, can propose modifications to its own base persona instructions. These proposals could be reviewed or automatically applied under certain conditions.
    *   The diary itself could track "meta-parameters" about personality drift or confidence in certain traits.

*   **Simulated Inter-Minion Relationships:**
    *   The existing `opinion_scores` in diaries primarily focus on the 'User' and other participants in the *current* interaction. This can be expanded.
    *   Minions could maintain a more persistent and distinct set of opinion scores or relationship statuses (e.g., ally, rival, neutral, trusted, distrusted) specifically for *other Minions* they interact with frequently across different contexts.
    *   These inter-Minion relationship scores would influence their behavior in Minion-to-Minion (M2M) channels, their willingness to collaborate, share information, or even how they interpret messages from other Minions.
    *   This would likely require expanding the diary structure to accommodate these M2M scores and modifying system/meta prompts to instruct Minions on how to use this information.

## V. Conclusion

The integration of AeroChat features into ADK Minions represents a significant step towards creating more sophisticated, engaging,and believable AI agents. By carefully porting the core logic for conversational turn-taking, personal emotional diaries, and channel-aware memory from the `llmchat` prototype, and by thoughtfully adapting these to the ADK framework, we can build a new generation of Minions. This strategy prioritizes the establishment of a solid foundation with mandatory features, paving the way for exciting future enhancements that will further deepen the dynamic capabilities of the Minion legion.